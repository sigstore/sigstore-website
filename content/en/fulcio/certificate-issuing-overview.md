---
title: "Certificate Issuing Overview"
menuTitle: "Certificate Issuing"
category: "Fulcio"
position: 203
---

This page will walk through the process of issuing a code signing certificate from start to finish as an entry point to understanding how Fulcio works.

## 1 — Certificate request input

![Fulcio certificate request input](/fulcio-1-certificate-request-input.png)

As a first step, the client submits a certificate request to Fulcio. This certificate request contains three items:

- An OIDC identity token, which is constructed as a JWT (JSON web token) containing information about the principal (identity of our client), the issuer (who verified this identity), and related metadata.
- The public key, which is the public half of an asymmetric key-pair generated by the client. The public key will be embedded in the final x509 certificate if this request is successful.
- A challenge which proves the client is in possession of the private key that corresponds to the public key provided. This challenge is created by signing the subject portion of the OIDC ID token.

## 2 — Authentication

![Fulcio authentication](/fulcio-2-authentication.png)

Authenticating the OIDC ID token begins the processing of the certificate request.

To authorize the token, Fulcio must:

- Use the issuer claim from the token to find the issuer's OIDC discovery endpoint
- Download the issuer's signing keys from the discovery endpoint
- Verify the ID token signature

## 3 — Verifying the challenge

![Fulcio verifying the challenge](/fulcio-3-verify-the-challenge.png)

Once the client has been authenticated, the next step is to verify that the client is in possession of the private key of the public key they’ve submitted. To do this, we must verify the challenge. This is a signature of the subject identifier — or sub — claim that allows for the verification of the signature using the public key supplied.

## 4 — Constructing a certificate

![Fulcio issue the certificate](/fulcio-4-issue-certificate.png)

The client is now authorized and has proven that they own their private key, so a code signing certificate can be issued.

At a high level this process involves:

- Embedding the provided public key in the certificate
- Setting the subject alternative names to match the sub claim from the OIDC ID token
- Setting various other customer x509 extensions depending on the metadata in the OIDC ID token claims 

## 5 — Signing the certificate

![Fulcio signing the certificate](/fulcio-5-sign-certificate.png)

The code signing certificate is now complete in detail, but needs to be signed by the certificate authority so that it becomes connected to Fulcio's chain of trust.

Fulcio supports several certificate authority backends:

- PKCS#11: This works with any PKCS#11 devices including AWS CloudHSM, [softHSM](https://www.opendnssec.org/softhsm/), and others
- Google Private CA: A hosted certificate authority created by Google Cloud Platform
- Files: A private key and certificate on disk
- Ephemeral: An in-memory key-pair generated on start up 

## 6 — Certificate Transparency log upload

![Fulcio upload the certificate to the transparency log](/fulcio-6-transparency-log-upload.png)

Once the certificate is signed, there is one final task to complete before returning the certificate to the client: it must be uploaded to a certificate transparency log.

The certificate transparency log returns a _Signed Certificate Timestamp_ (SCT), which indicates the log index for the certificate, a timestamp of when it was included, and this is all signed by the certificate transparency log.

## 7 — Return certificate to client

![Fulcio return the certificate to the client](/fulcio-7-return-to-client.png)

Finally, both the certificate and the SCT are returned to the client!